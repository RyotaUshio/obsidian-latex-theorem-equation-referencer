import argparse
from pathlib import Path
import os
import re
from pprint import pprint

def escape_space(path: Path):
    return str(path).replace(' ', r'\ ')

def to_string(path: Path):
    if isinstance(path, Path):
        return str(path.resolve())
    if isinstance(path, str):
        return path
    else:
        raise TypeError('Only Path or str is allowed')

def remove_comment(line: str):
    m = re.search(r'(?<!\\)%', line)
    return line[:m.start()] if m else line

PATTERN_CREF = re.compile(r'\\(C|c)ref\{(.*?)\}')
def cref_to_ref(line):
    return re.sub(PATTERN_CREF, r' \\ref{\2} ', line)

def ensure_newline(line):
    if not line.endswith('\n'):
        line += '\n'
    return line

PATTERN_INPUT = re.compile(r'\\(input|include)\{(.*?)\}')

def replace_input(line: str, build_dir: Path):
    return re.sub(
        PATTERN_INPUT, 
        lambda m: '\\' + m.groups()[0] + '{' + str(build_dir / m.groups()[1]) + '}', 
        line
    )

def preprocess(root: Path, tex_path: Path, build_dir: Path):
    build_dir = Path(build_dir)
    preprocessed_path = build_dir / tex_path.relative_to(root)
    preprocessed_path.parent.mkdir(exist_ok=True, parents=True)
    lines = ['\n', f'\\#begin {tex_path}\n' + '\n']
    with open(tex_path) as f:
        for i, line in enumerate(f):
            line = remove_comment(line)
            line = ensure_newline(line)
            line = replace_input(line, build_dir)            
            line = cref_to_ref(line)
            lines.append(line)

    lines += ['\n', f'\\#end {tex_path}\n' + '\n']

    with open(preprocessed_path, 'w') as f:
        f.writelines(lines)


def post_process(tmp_output: Path, output_dir: Path, root: Path):
    begin = '\\#begin '
    end = '\\#end '
    inside_div = False
    inside_proof = False
    inside_display_math = False
    include_stack = []
    path_lines_table = []
    with open(tmp_output) as f:
        for i, line in enumerate(f):
            # de-indent theorems
            if not inside_div and line.lstrip().startswith('> [!math'):
                inside_div = True
            if inside_div and not line.lstrip().startswith('>'):
                inside_div = False

            if inside_div:
                line = line.lstrip()

            # de-indent display math blocks
            if not inside_display_math and (line.strip().startswith('$$') or line.strip().endswith('$$')):
                inside_display_math = True
            if inside_display_math and (line.strip().startswith('$$') or line.strip().endswith('$$')):
                inside_display_math = False

            if inside_display_math:
                line = line.lstrip()

            # de-indent proofs
            if not inside_proof and '\\begin{proof}' in line:
                inside_proof = True
            if inside_proof:
                line = line.lstrip()
                if '\\end{proof}' in line:
                    inside_proof = False

            # process include directive
            if line.startswith(begin):
                # get info
                path = line[len(begin):]
                output_path = output_dir / Path(path).relative_to(root)
                output_path.parent.mkdir(exist_ok=True, parents=True)
                include_path = output_path.parent / (output_path.stem + '.md')

                # update stack
                if include_stack:
                    include_stack[-1]['lines'].append(f'[[{include_path.relative_to(output_dir)}]]' + '\n')
                include_stack.append({'path': include_path, 'lines': []})
                # print("pushed:")
                # pprint(include_stack)
                # print()
                continue
            if include_stack:
                if line.startswith(end):
                    path_lines_table.append(include_stack.pop())
                    # print("popped:")
                    # pprint(include_stack)
                    # print()
                    continue    

                include_stack[-1]['lines'].append(line)

    path_lines_table += include_stack
    # print("final:")
    # pprint(path_lines_table)

    for item in path_lines_table:
        print(f"write {item['path']}")
        with open(item['path'], 'w') as f:
            # no preceeding brank line, exactly one trailing brank line
            n_lines = len(item['lines'])
            if ''.join(item['lines']).strip():
                i = 0
                j = -1
                while not item['lines'][i].strip():
                    i += 1
                while not item['lines'][j].strip():
                    j -= 1
                lines = item['lines'][i:n_lines+j+1]
                f.writelines(lines)



if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('input', type=Path)
    parser.add_argument('build', type=Path)
    parser.add_argument('output', type=Path)
    parser.add_argument('filter', type=Path)
    args = parser.parse_args()

    root = args.input.parent
    tex_paths = list(root.glob('**/*.tex'))
    tmp_output = args.build / '__output.md'

    for tex_path in tex_paths:
        print(tex_path)
        preprocess(root, tex_path, args.build)


    cmd = f'pandoc {escape_space(to_string(args.build / args.input.relative_to(root)))} -s -f latex -t markdown --filter {escape_space(to_string(args.filter))} -o {escape_space(to_string(tmp_output))}'
    print(cmd)
    !{cmd}

    cmd = f'pandoc {escape_space(to_string(args.build / args.input.relative_to(root)))} -s -f latex -t json -o test/fml_build/ast_begin.json'
    print(cmd)
    !{cmd}

    post_process(tmp_output, args.output, root)

