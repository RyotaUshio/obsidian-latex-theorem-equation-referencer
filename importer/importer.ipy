import argparse
from pathlib import Path
import json
import re
from pprint import pprint

ROOT = Path('test/fml')

def escape_space(path: Path):
    return str(path).replace(' ', r'\ ')

def to_string(path: Path):
    if isinstance(path, Path):
        return str(path.resolve())
    if isinstance(path, str):
        return path
    else:
        raise TypeError('Only Path or str is allowed')

def remove_comment(line: str):
    m = re.search(r'(?<!\\)%', line)
    return line[:m.start()] if m else line

PATTERN_CREF = re.compile(r'\\(C|c)ref\{(.*?)\}')
def cref_to_ref(line):
    return re.sub(PATTERN_CREF, r' \\ref{\2} ', line)

def ensure_newline(line):
    if not line.endswith('\n'):
        line += '\n'
    return line

PATTERN_INPUT = re.compile(r'\\(input|include)\{(.*?)\}')

def replace_input(line: str, build_dir: Path):
    return re.sub(
        PATTERN_INPUT, 
        lambda m: '\\' + m.groups()[0] + '{' + str(build_dir / m.groups()[1]) + '}', 
        line
    )

def parse_labels(line, labels):
    for m in re.finditer(r'\\label\{(.*?)\}', line):
        label = m.groups()[0]
        labels.append(label)

def preprocess(root: Path, tex_path: Path, build_dir: Path, path_labels_table: dict):
    build_dir = Path(build_dir)
    relative_path = tex_path.relative_to(root)
    preprocessed_path = build_dir / relative_path
    preprocessed_path.parent.mkdir(exist_ok=True, parents=True)
    lines = ['\n', f'\\#begin {tex_path}\n' + '\n']
    without_suffix = str(relative_path.parent / relative_path.stem)
    with open(tex_path) as f:
        path_labels_table[without_suffix] = []
        for i, line in enumerate(f):
            line = remove_comment(line)
            line = ensure_newline(line)
            line = replace_input(line, build_dir)            
            line = cref_to_ref(line)
            parse_labels(line, path_labels_table[without_suffix])
            lines.append(line)

    lines += ['\n', f'\\#end {tex_path}\n' + '\n']

    with open(preprocessed_path, 'w') as f:
        f.writelines(lines)


def post_process(tmp_output: Path, output_dir: Path, root: Path):
    begin = '\\#begin '
    end = '\\#end '
    inside_div = False
    inside_proof = False
    inside_display_math = False
    include_stack = []
    path_lines_table = []
    footnote_buffer = []
    with open(tmp_output) as f:
        for i, line in enumerate(f):
            # de-indent theorems
            if not inside_div and line.lstrip().startswith('> [!math'):
                inside_div = True
            if inside_div and not line.lstrip().startswith('>'):
                inside_div = False

            if inside_div:
                line = line.lstrip()

            # de-indent display math blocks
            if not inside_display_math and (line.strip().startswith('$$') or line.strip().endswith('$$')):
                inside_display_math = True
            if inside_display_math and (line.strip().startswith('$$') or line.strip().endswith('$$')):
                inside_display_math = False

            if inside_display_math:
                line = line.lstrip()

            # some brute force
            if line.lstrip().startswith('>     '):
                line = '> ' + line[len('>     '):]

            # de-indent proofs
            if not inside_proof and '\\begin{proof}' in line:
                inside_proof = True
            if inside_proof:
                line = line.lstrip()
                if '\\end{proof}' in line:
                    inside_proof = False

            # process footnotes
            if footnote_buffer:
                footnote_buffer.append(line)

            footnote_labels = re.findall(r'\[\^[1-9][0-9]*?\]', line)
            if footnote_labels:
                if include_stack:
                    include_stack[-1]['footnotes'].extend(footnote_labels)
                else:
                    # stack is empty = footnote body
                    assert len(footnote_labels) == 1
                    label = footnote_labels[0]
                    if footnote_buffer:
                        path_lines_table_item = None
                        for item in path_lines_table:
                            if label in item['footnotes']:
                                path_lines_table_item = item 
                                break
                        if path_lines_table_item:
                            path_lines_table_item['lines'].extend(footnote_buffer)
                    footnote_buffer = [line]

            

            # process include directive
            if line.startswith(begin):
                # get info
                path = line[len(begin):]
                output_path = output_dir / Path(path).relative_to(root)
                output_path.parent.mkdir(exist_ok=True, parents=True)
                include_path = output_path.parent / (output_path.stem + '.md')

                # update stack
                if include_stack:
                    include_stack[-1]['lines'].append(f'[[{include_path.relative_to(output_dir)}]]' + '\n')
                include_stack.append({'path': include_path, 'lines': [], 'footnotes': []})
                # print("pushed:")
                # pprint(include_stack)
                # print()
                continue
            if include_stack:
                if line.startswith(end):
                    path_lines_table.append(include_stack.pop())
                    # print("popped:")
                    # pprint(include_stack)
                    # print()
                    continue

                append_to_last_line = False
                if inside_div and include_stack[-1]['lines']:
                    lines = include_stack[-1]['lines']
                    line_content = lines[-1].lstrip('> ').strip(' \n')

                    if line.lstrip(' >').strip(' \n') and line_content and not line_content.startswith('[!math'):
                        lines[-1] = lines[-1].rstrip('\n') + line.lstrip('>')
                        append_to_last_line = True
                if not append_to_last_line:
                    include_stack[-1]['lines'].append(ensure_newline(line))

    path_lines_table += include_stack
    # print("final:")
    # pprint(path_lines_table)

    for item in path_lines_table:
        print(f"write {item['path']}")
        with open(item['path'], 'w') as f:
            # no preceeding brank line, exactly one trailing brank line
            n_lines = len(item['lines'])
            if ''.join(item['lines']).strip():
                i = 0
                j = -1
                while not item['lines'][i].strip():
                    i += 1
                while not item['lines'][j].strip():
                    j -= 1
                lines = item['lines'][i:n_lines+j+1]
                f.writelines(lines)



if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('input', type=Path)
    parser.add_argument('build', type=Path)
    parser.add_argument('output', type=Path)
    parser.add_argument('filter', type=Path)
    args = parser.parse_args()

    root = args.input.parent
    tex_paths = list(root.glob('**/*.tex'))
    tmp_output = args.build / '__output.md'
    labels_path = args.build / '__labels.json'

    path_labels_table = {}

    for tex_path in tex_paths:
        print(f'preprocess {tex_path}')
        preprocess(root, tex_path, args.build, path_labels_table)

    with open(labels_path, 'w') as f:
        json.dump(path_labels_table, f)

    cmd = f'pandoc {escape_space(to_string(args.build / args.input.relative_to(root)))} -s -f latex -t markdown --filter {escape_space(to_string(args.filter))} -o {escape_space(to_string(tmp_output))}'
    print(cmd)
    !{cmd}

    cmd = f'pandoc {escape_space(to_string(args.build / args.input.relative_to(root)))} -s -f latex -t json -o test/fml_build/ast_begin.json'
    print(cmd)
    !{cmd}

    print('postprocessing...')
    post_process(tmp_output, args.output, root)

